package DistributeDataBase.rule.bean;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

import DistributeDataBase.common.DBType;
import DistributeDataBase.rule.LogicTableRule;
import DistributeDataBase.rule.ruleengine.entities.abstractentities.ListSharedElement;
import DistributeDataBase.rule.ruleengine.entities.abstractentities.OneToManyEntry;
import DistributeDataBase.rule.ruleengine.entities.abstractentities.RuleChain;
import DistributeDataBase.rule.ruleengine.entities.abstractentities.SharedElement;
import DistributeDataBase.rule.ruleengine.entities.abstractentities.TablePropertiesSetter;
import DistributeDataBase.rule.ruleengine.entities.convientobjectmaker.DatabaseMapProvider;
import DistributeDataBase.rule.ruleengine.entities.convientobjectmaker.TableMapProvider;
import DistributeDataBase.rule.ruleengine.entities.inputvalue.CalculationContextInternal;
import DistributeDataBase.rule.ruleengine.entities.retvalue.TargetDB;
import DistributeDataBase.rule.ruleengine.rule.ListAbstractResultRule;

public class LogicTable extends ListSharedElement
  implements Cloneable, LogicTableRule, TablePropertiesSetter
{
  private static final Logger log = Logger.getLogger(LogicTable.class);
  private OneToManyEntry oneToManyEntry = new OneToManyEntry();

  private DatabaseMapProvider databaseMapProvider = null;

  private DBType dbType = DBType.MYSQL;
  private boolean allowReverseOutput;
  private List<String> uniqueKeys;
  private Set<RuleChain> ruleChainSet = new HashSet();

  protected Map<String, Database> buildSubSharedMap(Map<String, Database> generatedDatabaseMap)
  {
    if ((this.subSharedElement == null) || (this.subSharedElement.size() == 0))
    {
      if (log.isDebugEnabled()) {
        log.debug("subShared element is null ,use sharedElement generated by database shared element map provider.");
      }

      return generatedDatabaseMap;
    }
    if (log.isDebugEnabled()) {
      log.debug("subSharedElement is not null,putAll current subSharedElement to generated sharedElement");
    }

    Map beAppendMap = this.subSharedElement;
    generatedDatabaseMap.putAll(beAppendMap);

    if (log.isDebugEnabled()) {
      log.debug("sub shared element is " + generatedDatabaseMap);
    }
    return generatedDatabaseMap;
  }

  public Object clone() throws CloneNotSupportedException {
    return super.clone();
  }

  public DatabaseMapProvider getDatabaseMapProvider() {
    return this.databaseMapProvider;
  }

  public Set<RuleChain> getRuleChainSet() {
    return this.ruleChainSet;
  }

  public void init()
  {
    initDatabaseByDatabaseMapProvider();

    if ((this.subSharedElement == null) || (this.subSharedElement.isEmpty())) {
      throw new IllegalArgumentException("最少必须指定一个库");
    }
    this.oneToManyEntry.init();

    for (Map.Entry sharedElement : this.subSharedElement.entrySet()) {
      ((SharedElement)sharedElement.getValue()).put(this.oneToManyEntry);
    }

    super.init();

    registeRule(this.ruleChainSet);
    if (log.isDebugEnabled())
      log.debug("rule chain set [" + this.ruleChainSet + "] inited;");
  }

  protected void initDatabaseByDatabaseMapProvider()
  {
    if (this.databaseMapProvider != null) {
      Map generatedDatabaseMap = this.databaseMapProvider.getDatabaseMap();
      if (generatedDatabaseMap != null)
        this.subSharedElement = buildSubSharedMap(generatedDatabaseMap);
    }
  }

  public void setDatabase(Map<String, SharedElement> databasesMap)
  {
    if (databasesMap != null)
      this.subSharedElement = databasesMap;
  }

  public void setDatabaseMapProvider(DatabaseMapProvider databaseMapProvider)
  {
    this.databaseMapProvider = databaseMapProvider;
  }

  public void setDatabaseRule(List<ListAbstractResultRule> databaseRule) {
    RuleChainImp ruleChainImp = new RuleChainImp();
    ruleChainImp.setListResultRule(databaseRule);
    ruleChainImp.setDatabaseRuleChain(true);
    ruleChainImp.init();
    this.listResultRule = ruleChainImp;
  }

  public List<TargetDB> getAllTargetDBList()
  {
    List targetDatabases = new ArrayList();
    Map beingSelectedDatabases = getSubSharedElements();
    for (Database database : beingSelectedDatabases.values()) {
      TargetDB db = new TargetDB();
      db.setDbIndex(database.getDataSourceKey());
      Set tempTableNameSet = new HashSet();
      Map tablesMap = database.getTables();
      Collection tableSharedElement = tablesMap.values();
      for (SharedElement shearedElement : tableSharedElement) {
        Table table = (Table)shearedElement;
        tempTableNameSet.add(table.getTableName());
      }
      db.setTableNames(tempTableNameSet);
      targetDatabases.add(db);
    }
    return targetDatabases;
  }

  public void setDBType(DBType dbType)
  {
    this.dbType = dbType;
  }

  public boolean isAllowReverseOutput() {
    return this.allowReverseOutput;
  }

  public void setAllowReverseOutput(boolean allowReverseOutput) {
    this.allowReverseOutput = allowReverseOutput;
  }

  public List<String> getUniqueColumns() {
    return this.uniqueKeys;
  }

  public List<String> getUniqueKeys() {
    return this.uniqueKeys;
  }

  public void setUniqueKeys(List<String> uniqueKeys) {
    this.uniqueKeys = uniqueKeys;
  }

  public List<TargetDB> calculate(Map<RuleChain, CalculationContextInternal> map)
  {
    CalculationContextInternal calculationContext = (CalculationContextInternal)map.get(this.listResultRule);
    Map resultmap = null;
    if (calculationContext == null)
    {
      if ((this.subSharedElement != null) && (this.subSharedElement.size() == 1))
      {
        resultmap = buildSingleDatabase();
      }
      else
        resultmap = buildDefaultDatabaseMap();
    }
    else
    {
      ListAbstractResultRule rule = calculationContext.ruleChain.getRuleByIndex(calculationContext.index);

      resultmap = rule.eval(calculationContext.sqlArgs);
    }

    List targetDBList = buildTargetDBList(map, resultmap);

    return targetDBList;
  }

  final Map<String, Field> buildDefaultDatabaseMap()
  {
    Map resultmap = new HashMap(this.defaultListResult.size());
    for (String defaultIndex : this.defaultListResult) {
      resultmap.put(defaultIndex, Field.EMPTY_FIELD);
    }
    return resultmap;
  }

  final List<TargetDB> buildTargetDBList(Map<RuleChain, CalculationContextInternal> map, Map<String, Field> resultmap)
  {
    List targetDBList = new ArrayList();
    for (Map.Entry entry : resultmap.entrySet()) {
      Database database = (Database)this.subSharedElement.get(entry.getKey());
      if (database == null) {
        throw new IllegalArgumentException("不能根据key: " + (String)entry.getKey() + "取到对应的表名，当前子规则中所有表名为:" + this.subSharedElement);
      }

      TargetDB targetDB = new TargetDB();
      String dbKey = database.getDataSourceKey();
      if (dbKey == null) {
        throw new IllegalArgumentException("database对象不包含数据源key id");
      }
      targetDB.setDbIndex(dbKey);
      database.calculateTable(targetDB, (Field)entry.getValue(), map);
      targetDBList.add(targetDB);
    }

    return targetDBList;
  }

  final Map<String, Field> buildSingleDatabase()
  {
    Map resultmap = new HashMap(1);
    for (String key : this.subSharedElement.keySet()) {
      resultmap.put(key, Field.EMPTY_FIELD);
    }
    return resultmap;
  }

  public void setLogicTableName(String logicTable) {
    this.oneToManyEntry.setLogicTableName(logicTable);
  }

  public String getLogicTableName() {
    return this.oneToManyEntry.getLogicTableName();
  }

  public void setTableRuleChain(RuleChain ruleChain) {
    this.oneToManyEntry.setTableRuleChain(ruleChain);
  }

  public void setTableMapProvider(TableMapProvider tableMapProvider) {
    this.oneToManyEntry.setTableMapProvider(tableMapProvider);
  }

  public TableMapProvider getTableMapProvider() {
    return this.oneToManyEntry.getTableMapProvider();
  }

  public String toString()
  {
    return "LogicTable [allowReverseOutput=" + this.allowReverseOutput + ", databaseMapProvider=" + this.databaseMapProvider + ", dbType=" + this.dbType + ", uniqueKeys=" + this.uniqueKeys + ", defaultListResult=" + this.defaultListResult + ", defaultListResultStragety=" + this.defaultListResultStragety + ", listResultRule=" + this.listResultRule + ", subSharedElement=" + this.subSharedElement + "]";
  }

  public void setDefaultListResultStragety(ListSharedElement.DEFAULT_LIST_RESULT_STRAGETY defaultListResultStragety)
  {
    super.setDefaultListResultStragety(defaultListResultStragety);
    this.oneToManyEntry.setDefaultListResultStragety(defaultListResultStragety);
  }

  public void setTableRule(List<ListAbstractResultRule> tableRule) {
    this.oneToManyEntry.setTableRule(tableRule);
  }

  public List<ListAbstractResultRule> getTableRule() {
    return this.oneToManyEntry.getTableRule();
  }
}